#!/bin/python3
import os, sys, subprocess, tempfile
import argparse
import colorama
import concurrent.futures
import hashlib
import requests

def print_warning(arg):
    print(colorama.Fore.YELLOW + arg, file=sys.stderr)

def print_error(arg):
    print(colorama.Fore.RED + arg, file=sys.stderr)

def print_success(arg):
    print(colorama.Fore.GREEN + arg)

def parse_args():
    parser = argparse.ArgumentParser(
        description='Get movie subtitles using napiprojekt.pl database')

    parser.add_argument(
        metavar='FILE',
        dest='paths',
        nargs='+',
        help='file to download subtitles for')

    parser.add_argument(
        '--lang',
        metavar='LANG',
        help='language to download subtitles in',
        default='pl',
        choices=('pl', 'en'))

    parser.add_argument(
        '-f',
        '--force',
        action='store_true',
        help='overwrite existing subtitles')

    return parser.parse_args()

def flat_walk(top):
    for path, dirs, filenames in os.walk(top):
        for filename in filenames:
            yield os.path.join(path, filename)

def collect_paths(paths):
    movie_extensions = 'avi,mp4,mpg,mkv'.split(',')
    for path in paths:
        if not os.path.exists(path):
            print_warning('Warning: %s does not exist' % path)
            continue
        if os.path.isdir(path):
            for child_path in flat_walk(path):
                extension = os.path.splitext(child_path)[1].lower().lstrip('.')
                if extension in movie_extensions:
                    yield child_path
        else:
            yield path

def get_md5(path):
    with open(path, 'rb') as fh:
        m = hashlib.md5()
        m.update(fh.read(1024 * 1024 * 10))
        return m.hexdigest()

def get_checksum(md5):
    checksum=''
    add = (0, 13, 16, 11, 5)
    mul = (2, 2, 5, 4, 3)
    idx = (14, 3, 6, 8, 2)
    for i in range(5):
        a=add[i]
        m=mul[i]
        x=idx[i]
        t = a + int(md5[x], 16)
        v = int(md5[t:t+2], 16)
        checksum += '%x' % ((v * m) % 16)
    return checksum

def process_path(movie_path, lang, force):
    subs_path = os.path.splitext(movie_path)[0] + '.sub'
    if os.path.exists(subs_path) and not force:
        print_warning('%r has subs, ignoring' % movie_path)
        return

    md5 = get_md5(movie_path)
    checksum = get_checksum(md5)
    password = 'iBlm8NTigvru0Jr0'

    url=('http://napiprojekt.pl/unit_napisy/dl.php'
        + '?l={lang}'
        + '&f={md5}'
        + '&t={checksum}'
        + '&v=other'
        + '&kolejka=false'
        + '&nick='
        + '&pass='
        + '&napios=posix').format(lang=lang.upper(), md5=md5, checksum=checksum)

    try:
        response = requests.get(url, timeout=3)
        if response.content[0:3] == b'NPc':
            raise RuntimeError('Subtitles not found.')
        with tempfile.NamedTemporaryFile(suffix='.7z', delete=False) as arc_file:
            arc_file.write(response.content)
            arc_path = arc_file.name
        try:
            cmd = ['7z', 'x', '-so', '-p' + password, arc_path]
            proc = subprocess.Popen(
                cmd,
                stderr=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stdin=subprocess.PIPE)
            output = proc.communicate(response.content)[0]
            with open(subs_path, 'wb') as sub_file:
                sub_file.write(output)
                print_success('%r saved' % movie_path)
        finally:
            if os.path.exists(arc_path):
                os.unlink(arc_path)
    except Exception as ex:
        print_error('%r error: %s' % (movie_path, ex))

def main():
    colorama.init()

    args = parse_args()
    paths = collect_paths(args.paths)
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        for path in paths:
            executor.submit(process_path, path, args.lang, args.force)

if __name__ == '__main__':
    main()
