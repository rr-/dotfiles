#!/usr/bin/python3
import argparse
import re, json
import os, sys, copy
import readline

try:
    import requests
    import colorama
except ImportError as e:
    if e.name is None:
        raise
    print('Please install %s.' % e.name)
    exit(1)

def colored(what, color):
    color_code = getattr(colorama.Fore, color.upper().replace('LIGHT', '').strip('_'))
    if 'light' in color.lower():
        color_code += colorama.Style.BRIGHT
    reset_code = colorama.Style.RESET_ALL
    return color_code + str(what) + reset_code

class istr(str):
    def __init__(self, *args):
        self._lowered = str.lower(self)
    def __repr__(self):
        return '%s(%s)' % (type(self).__name__, str.__repr__(self))
    def __hash__(self):
        return hash(self._lowered)
    def lower(self):
        return self._lowered
def _make_case_insensitive(name):
    original_method = getattr(str, name)
    def x(self, other, *args):
        try:
            other = other.lower()
        except (TypeError, AttributeError, ValueError):
            pass
        return original_method(self._lowered, other, *args)
    setattr(istr, name, x)
for name in 'eq ne lt le gt ge contains'.split():
    _make_case_insensitive('__%s__' % name)
for name in 'count endswith find index rfind rindex startswith'.split():
    _make_case_insensitive(name)
del _make_case_insensitive



class Tag(object):
    def __init__(self, name=None, usages=0, suggestions=[], implications=[]):
        self.name = name
        self.usages = usages
        self.implications = implications
        self.suggestions = suggestions

    @staticmethod
    def from_api_response(r):
        tag = Tag(name=istr(r['name']), usages=r['usages'])
        if 'implications' in r:
            tag.implications = [istr(t) for t in r['implications']]
        if 'suggestions' in r:
            tag.suggestions = [istr(t) for t in r['suggestions']]
        return tag

class Post(object):
    def __init__(
            self,
            id=None,
            tags=None,
            last_edit_time=None,
            safety='safe',
            content_file_name=None):
        self.id = id
        self.tags = tags
        self.safety = safety
        self.content_file_name = content_file_name
        self.last_edit_time = last_edit_time

    @staticmethod
    def from_api_response(r):
        return Post(
            id=r['id'],
            tags=[Tag.from_api_response(t) for t in r['tags']],
            safety=r['safety'],
            last_edit_time=r['lastEditTime'])

class BooruApi(object):
    def __init__(self, url):
        self.session = requests.Session()
        self.api_url = url + '/api'
        self.data_url = url + '/data'

    def get_tags(self):
        r = self.session.get(self.data_url + '/tags.json', verify=False)
        tags = [Tag.from_api_response(t) for t in json.loads(r.text)]
        return sorted(tags, key=lambda tag: -tag.usages)

    def get_tag_siblings(self, word):
        r = self._verify_response(
            self.session.get(
                self.api_url + '/tags/' + str(word) + '/siblings'))
        return [Tag.from_api_response(t) for t in json.loads(r.text)['tags']]

    def login(self, user, password):
        r = self._verify_response(
            self.session.post(
                self.api_url + '/login',
                data={'userNameOrEmail': user, 'password': password},
                verify=False))
        auth_token = json.loads(r.text)['token']['name']
        self.session.headers.update({'x-authorization-token': auth_token})

    def upload_post(self, post, content_path):
        with open(content_path, 'rb') as fh:
            files = {'content': fh}
            self._verify_response(
                self.session.post(
                    self.api_url + '/posts',
                    files=files,
                    data={
                        'contentFileName': post.content_file_name,
                        'source': '',
                        'safety': post.safety,
                        'anonymous': 0,
                        'tags': ' '.join(t.name for t in post.tags)
                    }))

    def update_post(self, post):
        self._verify_response(
            self.session.post(
                self.api_url + '/posts/' + str(post.id),
                data={
                    'safety': post.safety,
                    'tags': ' '.join(t.name for t in post.tags),
                    'lastEditTime': post.last_edit_time,
                }))

    def get_post(self, post_id):
        r = self._verify_response(
            self.session.get(
                self.api_url + '/posts/' + str(post_id)))
        return Post.from_api_response(json.loads(r.text)['post'])

    def _verify_response(self, response):
        if response.status_code != 200:
            raise RuntimeError(json.loads(response.text)['error'])
        return response



class Tagger(object):
    def __init__(self, tagger_settings, booru_api):
        self.chosen_tags = []
        self.install_tag_completer()
        self.tag_dict = {tag.name: tag for tag in tagger_settings}
        self.all_tags = [tag.name for tag in tagger_settings]
        self.booru_api = booru_api

    def install_tag_completer(self):
        self.rl_completion_append_character = None
        self.rl_completion_suppress_append = None

        for lib in ['libreadline.so', 'libreadline.dll', 'cygreadline7.dll']:
            try:
                import ctypes
                rl = ctypes.cdll.LoadLibrary(lib)
                ctypes.c_ulong.in_dll(
                    rl, 'rl_sort_completion_matches').value = 0
                self.rl_completion_append_character = ctypes.c_char.in_dll(
                    rl, 'rl_completion_append_character')
                self.rl_completion_suppress_append = ctypes.c_int.in_dll(
                    rl, 'rl_completion_suppress_append')
            except:
                pass

        def completer(text, state):
            if self.rl_completion_append_character is not None:
                self.rl_completion_append_character.value = ord(' ')
            if self.rl_completion_suppress_append is not None:
                self.rl_completion_suppress_append.value = 0

            if len(text) >= 3:
                options = [tag for tag in self.all_tags if text in tag]
            else:
                options = [tag for tag in self.all_tags if tag.startswith(text)]

            try:
                return options[state]
            except IndexError:
                return None

        readline.set_completer(completer)
        readline.parse_and_bind('tab: menu-complete')

    def print(self):
        for word in self.chosen_tags:
            color = 'light_cyan' if word in self.tag_dict else 'light_red'
            print(colored('+ %s' % word, color))

    def tagged(self, word):
        return word in self.chosen_tags

    def remove(self, word):
        if word in self.chosen_tags:
            self.chosen_tags.remove(word)

    def add(self, tag):
        if tag in self.chosen_tags:
            return
        self.chosen_tags.append(tag)
        if tag not in self.tag_dict:
            print(colored('Warning: new tag', 'light_red'))

    def add_from_user_input(self):
        try:
            while True:
                line = input('#' + str(len(self.chosen_tags)) + '> ').strip()
                if line == '':
                    self.print()
                    continue

                previous_tags = copy.deepcopy(self.chosen_tags)
                for word in set(line.split(' ')):
                    self._handle_input_word(word)
                new_tags = [
                    word
                    for word in self.chosen_tags
                    if word not in previous_tags]

                stack = copy.deepcopy(new_tags)
                implications = set()
                suggestions = set()
                while stack:
                    word = stack.pop()
                    if word not in self.tag_dict:
                        continue
                    tag = self.tag_dict[word]
                    for implication in tag.implications:
                        if implication not in self.chosen_tags:
                            implications.add(implication)
                            stack.append(implication)
                    for suggestion in tag.suggestions:
                        if suggestion not in self.chosen_tags:
                            suggestions.add(suggestion)
                suggestions -= implications
                for implication in implications:
                    print(colored('+ ' + implication, 'green'))
                    self.add(implication)
                for suggestion in suggestions:
                    print(colored('? ' + suggestion, 'yellow'))

        except EOFError:
            print('(EOF)')

    def _handle_input_word(self, word):
        if word.startswith('-'):
            tag = istr(word[1:])
            if tag:
                self.remove(tag)
            else:
                if self.chosen_tags:
                    self.remove(self.chosen_tags[-1])
                else:
                    print(colored('No tags to remove', 'yellow'))
        elif word.startswith('??'):
            tag = istr(word[2:])
            for sibling_tag in self.booru_api.get_tag_siblings(tag)[0:20]:
                print(colored('? %s' % sibling_tag.name, 'yellow'))
        elif word.startswith('?'):
            tag = istr(word[1:])
            if tag not in self.tag_dict:
                print(colored('No such tag', 'yellow'))
                return
            for implied_tag in self.tag_dict[tag].implications:
                print(colored('? %s' % implied_tag, 'green'))
            for suggested_tag in self.tag_dict[tag].suggestions:
                print(colored('? %s' % suggested_tag, 'yellow'))
        else:
            tag = istr(word)
            self.add(tag)

    def get(self):
        return [Tag(name=word) for word in self.chosen_tags]



def parse_args():
    parser = argparse.ArgumentParser(
        description='Sends post to szurubooru from CLI')
    parser.add_argument('-c', '--config', metavar='CONFIG_PATH',
        help='path to config JSON file', default='~/.config/booru.json')
    parser.add_argument('-w', '--wait', choices=['always', 'errors', 'never'],
        default='never', help='wait before exiting on errors')
    parser.add_argument(metavar='POST_PATH', dest='path',
        help='path to the post')
    return parser.parse_args()

def wait_for_user_input(message='Press Enter to continue...'):
    input(message)

def load_config(path):
    config = {}
    if path:
        path = os.path.expanduser(path)
        if not os.path.exists(path):
            print(colored('Warning: %s does not exist' % path, 'yellow'))
        else:
            with open(path, 'r') as fh:
                config = json.load(fh)
    return config

def fill_config(config):
    if 'url' not in config:
        config['url'] = input('Booru URL: ')
    if 'user' not in config:
        config['user'] = input('User: ')
    if 'password' not in config:
        from getpass import getpass
        config['password'] = getpass('Password: ')

def update_tags(booru_api, post_id, chosen_tags):
    post = booru_api.get_post(post_id)
    existing_tags = post.tags

    new_tags = {t.name: t for t in chosen_tags}
    for tag in existing_tags:
        if tag.name in new_tags:
            del new_tags[tag.name]
    new_tags = list(new_tags.values())

    if not new_tags:
        print('No new tags.')
        return
    print('Existing tags: %s' % ', '.join(t.name for t in existing_tags))
    print('New tags: %s' % colored(
        ', '.join(t.name for t in new_tags), 'light_green'))
    post.tags = existing_tags + new_tags
    wait_for_user_input('Press Enter to add new tags, Ctrl+C to exit...')
    booru_api.update_post(post)
    print(colored('Tags merge successful!', 'green'))

def upload(booru_api, tagger_settings, args):
    if not os.path.exists(args.path):
        raise RuntimeError('Post file does not exist')

    print('Entering tagging mode.', end=' ')
    print('^D to finish,', end=' ')
    print('^C to abort.')

    tagger = Tagger(tagger_settings, booru_api)
    tagger.add_from_user_input()

    safety = 'safe'
    for s in ['safe', 'sketchy', 'unsafe']:
        if tagger.tagged(s):
            safety = s
            tagger.remove(s)
    chosen_tags = set(tagger.get())

    print(colored(
        'Tags: %s' % ', '.join([tag.name for tag in chosen_tags]),
        'light_blue'))
    print(colored('Safety: %s' % safety, 'light_blue'))

    post = Post(
        safety=safety,
        tags=set(tagger.get()),
        content_file_name=os.path.basename(args.path))
    try:
        booru_api.upload_post(post, args.path)
        print(colored('Upload succesful!', 'green'))
    except Exception as e:
        if 'duplicate' not in str(e).lower():
            raise
        print(colored(e, 'light_red'))
        post_id = int(re.search('([0-9]+)', str(e)).group(0))
        update_tags(booru_api, post_id, chosen_tags)

def main():
    colorama.init()
    requests.packages.urllib3.disable_warnings()

    args = parse_args()
    try:
        config = load_config(args.config)
        fill_config(config)

        booru_api = BooruApi(config['url'])
        booru_api.login(config['user'], config['password'])

        tagger_settings = list(booru_api.get_tags())
        tagger_settings.insert(0, Tag(name='unsafe', usages=999999))
        tagger_settings.insert(0, Tag(name='sketchy', usages=999999))
        tagger_settings.insert(0, Tag(name='safe', usages=999999))

        upload(booru_api, tagger_settings, args)

        if args.wait == 'always':
            wait_for_user_input()
    except Exception as e:
        print(colored('Upload unsuccesful...', 'light_red'))
        print(colored(e, 'light_red'))
        if args.wait in ['error', 'errors', 'always']:
            wait_for_user_input()

if __name__ == '__main__':
    main()
