#!/bin/python3
# Looks up images on IQDB from CLI.

import os
import sys
import argparse
import pathlib
import pickle
from dotfiles import iqdb
from dotfiles import logging

MANAGED_EXTENSIONS = ['jpg', 'jpeg', 'gif', 'png']

SORT_STYLE_URL = 'url'
SORT_STYLE_SIMILARITY = 'similarity'

GOOD_MATCH_THRESHOLD = 0.95
POSSIBLE_MATCH_THRESHOLD = 0.85

GOOD_MATCH_FOUND = 0
POSSIBLE_MATCH_FOUND = 1
NO_MATCH_FOUND = 2


def _parse_args():
    parser = argparse.ArgumentParser(description='Searches for image via IQDB')
    parser.add_argument('path', help='path to the image', nargs='*')
    parser.add_argument(
        '-f', '--filter', help='filter the results by URL', default='')
    parser.add_argument(
        '-s', '--sort',
        help='how to sort the results',
        choices=(SORT_STYLE_SIMILARITY, SORT_STYLE_URL),
        default=SORT_STYLE_SIMILARITY)
    parser.add_argument(
        '-n', '--no-cache', action='store_true',
        help='disable caching the results')
    parser.add_argument(
        '--separate', action='store_true',
        help='separate additional results')
    parser.add_argument(
        '--cache-path',
        default='/tmp/iqdb-cache.json', help='path to the cache file')
    args = parser.parse_args()
    if not args.path:
        args.path = ['.']
    return args


def _output_results(results, sort_style):
    if sort_style == SORT_STYLE_SIMILARITY:
        results = sorted(results, key=lambda _: -_.similarity)
    elif sort_style == SORT_STYLE_URL:
        results = sorted(results, key=lambda _: _.url)
    for result in results:
        text = '[%3.0f%%, %5sx%-5s] %s' % (
            result.similarity * 100,
            result.width or '?',
            result.height or '?',
            result.url)

        if result.similarity >= GOOD_MATCH_THRESHOLD:
            logging.success(text)
        elif result.similarity >= POSSIBLE_MATCH_THRESHOLD:
            logging.warning(text)
        else:
            logging.error(text)


def _get_cache_path(args):
    return os.path.expanduser(args.cache_path)


def _get_cache(args):
    cache_path = _get_cache_path(args)
    try:
        with open(cache_path, 'rb') as handle:
            return pickle.load(handle)
    except:
        return {}


def _save_cache(args, cache):
    cache_path = _get_cache_path(args)
    with open(cache_path, 'wb') as handle:
        pickle.dump(cache, handle)


def _get_results(path, args):
    path = os.path.realpath(path)
    if not args.no_cache:
        cache = _get_cache(args)
        if path in cache:
            return cache[path]

    try:
        results = iqdb.search(path)
    except iqdb.NothingFoundIqdbError:
        results = []

    if not args.no_cache:
        cache[path] = results
        _save_cache(args, cache)
    return results


def _process_path(path, args):
    logging.info('Input file: %s', path)
    logging.info('Input URL: %s', pathlib.Path(os.path.abspath(path)).as_uri())

    results = _get_results(path, args)

    for result in reversed(results):
        if args.filter not in result.url:
            results.remove(result)

    main_results = [_ for _ in results if _.main]
    extra_results = [_ for _ in results if not _.main]

    if not main_results:
        logging.error('No direct matches')
        logging.info('')
        return NO_MATCH_FOUND

    logging.info(
        'Input resolution: %sx%s',
        results.input_width or '?',
        results.input_height or '?')

    if args.separate:
        _output_results(main_results, args.sort)
        if extra_results:
            _output_results(extra_results, args.sort)
    else:
        _output_results(main_results + (extra_results or []), args.sort)
    logging.info('')

    if any(r for r in results if r.similarity >= GOOD_MATCH_THRESHOLD):
        return GOOD_MATCH_FOUND
    if any(r for r in results if r.similarity >= POSSIBLE_MATCH_THRESHOLD):
        return POSSIBLE_MATCH_FOUND
    return NO_MATCH_FOUND


def _collect_paths(paths):
    for path in paths:
        if os.path.isdir(path):
            for entry in os.scandir(path):
                if not entry.is_file:
                    continue
                ext = os.path.splitext(entry.path)[1].lstrip('.').lower()
                if ext in MANAGED_EXTENSIONS:
                    yield entry.path
        elif os.path.isfile(path):
            yield path


def main():
    args = _parse_args()
    exit_code = 0
    paths = list(_collect_paths(args.path))
    if not len(paths):
        logging.error('No images found in ' + ', '.join(args.path))
        sys.exit(1)
    for path in paths:
        exit_code = max(
            exit_code,
            _process_path(path, args))
    sys.exit(exit_code)


if __name__ == '__main__':
    logging.getLogger('requests').setLevel(logging.WARNING)
    main()
