#!/bin/python3
# Looks up images on IQDB from CLI.

import os
import sys
import argparse
import pathlib
from dotfiles import iqdb
from dotfiles import logging

logger = logging.getLogger(__name__)

SORT_STYLE_URL = 'url'
SORT_STYLE_SIMILARITY = 'similarity'

GOOD_MATCH_THRESHOLD = 0.95
POSSIBLE_MATCH_THRESHOLD = 0.85

GOOD_MATCH_FOUND = 0
POSSIBLE_MATCH_FOUND = 1
NO_MATCH_FOUND = 2


def _parse_args():
    parser = argparse.ArgumentParser(description='Searches for image via IQDB')
    parser.add_argument('path', help='path to the image', nargs='+')
    parser.add_argument(
        '-f', '--filter', help='filter the results by URL', default='')
    parser.add_argument(
        '-s', '--sort',
        help='how to sort the results',
        choices=(SORT_STYLE_SIMILARITY, SORT_STYLE_URL),
        default=SORT_STYLE_SIMILARITY)
    parser.add_argument(
        '--separate', action='store_true',
        help='separate additional results')
    return parser.parse_args()


def _output_results(results, sort_style):
    if sort_style == SORT_STYLE_SIMILARITY:
        results = sorted(results, key=lambda _: -_.similarity)
    elif sort_style == SORT_STYLE_URL:
        results = sorted(results, key=lambda _: _.url)
    for result in results:
        text = '[%3.0f%%, %5sx%-5s] %s' % (
            result.similarity * 100,
            result.width or '?',
            result.height or '?',
            result.url)

        if result.similarity >= GOOD_MATCH_THRESHOLD:
            logger.success(text)
        elif result.similarity >= POSSIBLE_MATCH_THRESHOLD:
            logger.warning(text)
        else:
            logger.error(text)


def _process_path(path, filter, sort_style, separate):
    logger.info('Input file: %s', path)
    logger.info('Input URL: %s', pathlib.Path(os.path.abspath(path)).as_uri())

    try:
        results = iqdb.search(path)
    except iqdb.NothingFoundIqdbError:
        results = []

    for result in reversed(results):
        if filter not in result.url:
            results.remove(result)

    main_results = [_ for _ in results if _.main]
    extra_results = [_ for _ in results if not _.main]

    if not main_results:
        logger.error('No direct matches')
        logger.info('')
        return NO_MATCH_FOUND

    logger.info(
        'Input resolution: %sx%s',
        results.input_width or '?',
        results.input_height or '?')

    if separate:
        _output_results(main_results, sort_style)
        if extra_results:
            _output_results(extra_results, sort_style)
    else:
        _output_results(main_results + (extra_results or []), sort_style)
    logger.info('')

    if any(r for r in results if r.similarity >= GOOD_MATCH_THRESHOLD):
        return GOOD_MATCH_FOUND
    if any(r for r in results if r.similarity >= POSSIBLE_MATCH_THRESHOLD):
        return POSSIBLE_MATCH_FOUND
    return NO_MATCH_FOUND


def main():
    args = _parse_args()
    exit_code = 0
    for path in args.path:
        exit_code = max(
            exit_code,
            _process_path(path, args.filter, args.sort, args.separate))
    sys.exit(exit_code)


if __name__ == '__main__':
    logging.getLogger('requests').setLevel(logging.WARNING)
    main()
