#!/usr/bin/env python3
import argparse
import asyncio
from pathlib import Path
from typing import Iterable, Optional
from concurrent.futures import ThreadPoolExecutor

import PIL.Image


class File:
    path: Path
    width: Optional[int]
    height: Optional[int]

    def __init__(self, path: Path) -> None:
        self.path = path
        self.width = None
        self.height = None

    @property
    def rank(self) -> int:
        return (self.width or -1) * (self.height or -1)


def collect_files(source_path: Path) -> Iterable[File]:
    for path in source_path.iterdir():
        if path.is_dir():
            continue
        if path.name.endswith(('png', 'jpg', 'gif')):
            yield File(path)


def fill_file_info(file: File) -> None:
    print(f'Querying {file.path.name}...')
    try:
        file.width, file.height = PIL.Image.open(str(file.path)).size
    except OSError:
        pass


def fill_file_infos(files: Iterable[File]) -> None:
    loop = asyncio.get_event_loop()
    executor = ThreadPoolExecutor(max_workers=8)

    futures = [
        loop.run_in_executor(executor, fill_file_info, file)
        for file in files
    ]
    loop.run_until_complete(asyncio.gather(*futures))


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument('source_dir', type=Path, default='.', nargs='?')
    parser.add_argument('-d', '--dry-run', action='store_true')
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    print('Collecting files...')
    files = list(collect_files(args.source_dir.resolve()))

    print('Querying image dimensions...')
    fill_file_infos(files)

    print('Renaming...')
    for i, file in enumerate(sorted(files, key=lambda file: file.rank)):
        target_path = file.path.parent / f'{i:04}_{file.path.name}'
        print(f'{file.path} -> {target_path} ({file.rank})')
        if not args.dry_run:
            file.path.rename(target_path)


if __name__ == '__main__':
    main()
