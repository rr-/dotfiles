#!/bin/python3

''' Downloads movie subtitles from Napiprojekt database. '''

import argparse
import concurrent.futures
import hashlib
import os
import subprocess
import sys
import tempfile
import colorama
import requests

PASSWORD = 'iBlm8NTigvru0Jr0'
URL_TEMPLATE = (
    'http://napiprojekt.pl/unit_napisy/dl.php'
    + '?l={lang}'
    + '&f={md5}'
    + '&t={checksum}'
    + '&v=other'
    + '&kolejka=false'
    + '&nick='
    + '&pass='
    + '&napios=posix')

def print_warning(arg):
    ''' Prints a warning message in yellow color. '''
    print(colorama.Fore.YELLOW + str(arg), file=sys.stderr)

def print_error(arg):
    ''' Prints an error message in red color. '''
    print(colorama.Fore.RED + str(arg), file=sys.stderr)

def print_success(arg):
    ''' Prints a message in green color. '''
    print(colorama.Fore.GREEN + arg)

def parse_args():
    ''' Parses arguments supplied by the user. '''
    parser = argparse.ArgumentParser(
        description='Get movie subtitles using napiprojekt.pl database')

    parser.add_argument(
        metavar='FILE',
        dest='paths',
        nargs='+',
        help='file to download subtitles for')

    parser.add_argument(
        '--lang',
        metavar='LANG',
        help='language to download subtitles in',
        default='pl',
        choices=('pl', 'en'))

    parser.add_argument(
        '-f',
        '--force',
        action='store_true',
        help='overwrite existing subtitles')

    return parser.parse_args()

def flat_walk(top):
    ''' Returns recursive list of files contained inside the directory. '''
    for path, _, filenames in os.walk(top):
        for filename in filenames:
            yield os.path.join(path, filename)

def collect_paths(paths):
    ''' Returns list of paths to movie files basing on arbitrary paths. '''
    movie_extensions = 'avi,mp4,mpg,mkv'.split(',')
    for path in paths:
        if not os.path.exists(path):
            print_warning('Warning: %s does not exist' % path)
            continue
        if os.path.isdir(path):
            for child_path in flat_walk(path):
                extension = os.path.splitext(child_path)[1].lower().lstrip('.')
                if extension in movie_extensions:
                    yield child_path
        else:
            yield path

def get_md5(path):
    ''' Gets the MD5 of the first 10 megabytes. '''
    with open(path, 'rb') as handle:
        md5 = hashlib.md5()
        md5.update(handle.read(1024 * 1024 * 10))
        return md5.hexdigest()

def get_checksum(md5):
    ''' Gets the checksum for Napiprojekt basing on the file's MD5. '''
    checksum = ''
    add = (0, 13, 16, 11, 5)
    mul = (2, 2, 5, 4, 3)
    idx = (14, 3, 6, 8, 2)
    for i in range(5):
        index = int(md5[idx[i]], 16) + add[i]
        value = int(md5[index:index+2], 16) * mul[i]
        checksum += '%x' % (value % 16)
    return checksum

def process_path(movie_path, lang, force):
    '''
    Stores subtitles for a single movie path.
    If the target subtitles already exist, bails out, unless force=True.
    '''
    subs_path = os.path.splitext(movie_path)[0] + '.sub'
    if os.path.exists(subs_path) and not force:
        print_warning('%r has subs, ignoring' % movie_path)
        return

    md5 = get_md5(movie_path)
    checksum = get_checksum(md5)
    url = URL_TEMPLATE.format(lang=lang.upper(), md5=md5, checksum=checksum)

    response = requests.get(url, timeout=3)
    if response.content[0:3] == b'NPc':
        print_error('%r error: subtitles not found.' % (movie_path))
        return

    with tempfile.NamedTemporaryFile(suffix='.7z', delete=False) as arc_file:
        arc_file.write(response.content)
        arc_path = arc_file.name
    try:
        cmd = ['7z', 'x', '-so', '-p' + PASSWORD, arc_path]
        proc = subprocess.Popen(
            cmd,
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE)
        output = proc.communicate(response.content)[0]
        with open(subs_path, 'wb') as sub_file:
            sub_file.write(output)
            print_success('%r saved' % movie_path)
    except Exception as e:
        print_error(e)
    finally:
        if os.path.exists(arc_path):
            os.unlink(arc_path)

def main():
    colorama.init()

    args = parse_args()
    paths = collect_paths(args.paths)
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        for path in paths:
            executor.submit(process_path, path, args.lang, args.force)

if __name__ == '__main__':
    main()
