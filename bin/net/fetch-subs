#!/bin/python3

''' Downloads movie subtitles from Napiprojekt database. '''

import argparse
import concurrent.futures
import hashlib
import os
import re
import subprocess
import sys
import tempfile

import colorama
import requests

PASSWORD = 'iBlm8NTigvru0Jr0'
URL_TEMPLATE = (
    'http://napiprojekt.pl/unit_napisy/dl.php'
    + '?l={lang}'
    + '&f={md5}'
    + '&t={checksum}'
    + '&v=other'
    + '&kolejka=false'
    + '&nick='
    + '&pass='
    + '&napios=posix')
MOVIE_EXTENSIONS = 'avi,mp4,mpg,mkv'.split(',')

class Subtitle():
    def __init__(self, time_start, time_end, text):
        self.time_start = time_start
        self.time_end = time_end
        self.text = text

class SubtitleReader():
    def __init__(self):
        self._regex = None

    def detect(self, lines):
        for line in lines:
            if self._regex.match(line):
                return True
        return False

    def read(self, lines, _fps):
        raise NotImplementedError()

class MdvdSubtitleReader(SubtitleReader):
    def __init__(self):
        super().__init__()
        self._regex = re.compile(r'^\{(\d+)\}\{(\d*)\}\s*(.*)')

    def read(self, lines, fps):
        for line in lines:
            match = self._regex.match(line)
            if match:
                time_start = [int(match.group(1)) / float(fps)]
                if match.group(2):
                    time_end = int(match.group(2)) / float(fps)
                else:
                    time_end = int(match.group(1)) / float(fps) + 3
                text = match.group(3).strip().split('|')
                yield Subtitle(time_start, time_end, text)

class Sub2SubtitleReader(SubtitleReader):
    def __init__(self):
        super().__init__()
        self._regex = re.compile(
            r'^(\d+):(\d+):(\d+)\.(\d+)\s*\,\s*(\d+):(\d+):(\d+)\.(\d+).*$')

    def read(self, lines, _fps):
        subtitles = []
        lines_it = iter(lines)
        for line in lines_it:
            match = self._regex.match(line)
            if match:
                time_start = (
                    int(match.group(1)) * 3600
                    + int(match.group(2)) * 60
                    + int(match.group(3))
                    + int(match.group(4)) / 100.0)
                time_end = (
                    int(match.group(5)) * 3600
                    + int(match.group(6)) * 60
                    + int(match.group(7))
                    + int(match.group(8)) / 100.0)
                text = next(lines_it).strip().split('[br]')
                yield Subtitle(time_start, time_end, text)

class SrtSubtitleReader(SubtitleReader):
    def __init__(self):
        super().__init__()
        self._regex = re.compile(r'^(\d+):(\d+):(\d+),\d+\s*-->.*')

    def read(self, lines, _fps):
        re1 = re.compile(r'^(\d+)\s*$')
        re2 = re.compile(
            r'^(\d+):(\d+):(\d+),(\d+)\s*-->\s*(\d+):(\d+):(\d+),(\d+).*$')
        re3 = re.compile(r'^\s*$')
        lines_it = iter(lines)
        for line in lines_it:
            if not re1.match(line):
                continue
            match = re2.match(next(lines_it))
            if not match:
                continue
            time_start = (
                int(match.group(1)) * 3600
                + int(match.group(2)) * 60
                + int(match.group(3))
                + int(match.group(4)) / 1000.0)
            time_end = (
                int(match.group(5)) * 3600
                + int(match.group(6)) * 60
                + int(match.group(7))
                + int(match.group(8)) / 1000.0)
            text_lines = []
            text = next(lines_it)
            while not re3.match(text, 0):
                text_lines.append(text.strip())
                text = next(lines_it)
            yield Subtitle(time_start, time_end, text_lines)

class TmpSubtitleReader(SubtitleReader):
    def __init__(self):
        super().__init__()
        self._regex = re.compile(r'^(\d+):(\d+):(\d+):(.*)')

    def read(self, lines, _fps):
        subs = {}
        for line in lines:
            match = self._regex.match(line, 0)
            if match:
                time = (
                    int(match.group(1)) * 3600
                    + int(match.group(2)) * 60
                    + int(match.group(3)))
                text = match.group(4).strip().split('|')
                if time in subs:
                    subs[time].extend(text)
                else:
                    subs[time] = text

        for time in sorted(subs.keys()):
            length = 1
            while (time + length) not in subs and length < 4:
                length = length + 1
            yield Subtitle(time, time + length, subs[time])

class Mpl2SubtitleReader(SubtitleReader):
    def __init__(self):
        super().__init__()
        self._regex = re.compile(
            r'\[(?P<start>\d+)\]\[(?P<stop>\d+)\](?P<line>.*)', re.S)

    def read(self, lines, _fps):
        for line in lines:
            match = self._regex.match(line)
            if not match:
                continue
            group = match.groupdict()
            start = float(group['start']) * 0.1
            stop = float(group['stop']) * 0.1
            text = group['line'].split('|')
            yield Subtitle(start, stop, text)

class SubtitleParser():
    def __init__(self):
        self._readers = []
        for subclass in SubtitleReader.__subclasses__():
            self._readers.append(subclass())

    def parse(self, lines, fps):
        for reader in self._readers:
            if reader.detect(lines):
                return list(reader.read(lines, fps))

    def to_srt(self, subtitles):
        out = ''
        for i, subtitle in enumerate(subtitles):
            out += '%d\n%.2d:%.2d:%.2d,%.3d --> %.2d:%.2d:%.2d,%.3d\n%s\n\n' % (
                i + 1,

                int(subtitle.time_start / 3600),
                int(int(subtitle.time_start % 3600) / 60),
                int(subtitle.time_start % 60),
                (subtitle.time_start - int(subtitle.time_start)) * 1000,

                int(subtitle.time_end / 3600),
                int(int(subtitle.time_end % 3600) / 60),
                int(subtitle.time_end % 60),
                (subtitle.time_end - int(subtitle.time_end)) * 1000,

                '\n'.join(subtitle.text))

        return out

def print_warning(arg):
    print(colorama.Fore.YELLOW + str(arg), file=sys.stderr)

def print_error(arg):
    print(colorama.Fore.RED + str(arg), file=sys.stderr)

def print_success(arg):
    print(colorama.Fore.GREEN + arg)

def parse_args():
    parser = argparse.ArgumentParser(
        description='Get movie subtitles using napiprojekt.pl database')

    parser.add_argument(
        metavar='FILE',
        dest='paths',
        nargs='+',
        help='file to download subtitles for')

    parser.add_argument(
        '--lang',
        metavar='LANG',
        help='language to download subtitles in',
        default='pl',
        choices=('pl', 'en'))

    parser.add_argument(
        '-f',
        '--force',
        action='store_true',
        help='overwrite existing subtitles')

    parser.add_argument(
        '-d',
        '--debug',
        action='store_true',
        help='show stacktraces')

    return parser.parse_args()

def flat_walk(top):
    ''' Returns recursive list of files contained inside the directory. '''
    for path, _, filenames in os.walk(top):
        for filename in filenames:
            yield os.path.join(path, filename)

def collect_paths(paths):
    for path in paths:
        if not os.path.exists(path):
            print_warning('Warning: %s does not exist' % path)
            continue
        if os.path.isdir(path):
            for child_path in flat_walk(path):
                extension = os.path.splitext(child_path)[1].lower().lstrip('.')
                if extension in MOVIE_EXTENSIONS:
                    yield child_path
        else:
            yield path

def get_fps(path):
    return 23.976

def get_md5(path):
    ''' Gets the MD5 of the first 10 megabytes. '''
    with open(path, 'rb') as handle:
        md5 = hashlib.md5()
        md5.update(handle.read(1024 * 1024 * 10))
        return md5.hexdigest()

def get_checksum(md5):
    ''' Gets the checksum for Napiprojekt basing on the file's MD5. '''
    checksum = ''
    add = (0, 13, 16, 11, 5)
    mul = (2, 2, 5, 4, 3)
    idx = (14, 3, 6, 8, 2)
    for i in range(5):
        index = int(md5[idx[i]], 16) + add[i]
        value = int(md5[index:index+2], 16) * mul[i]
        checksum += '%x' % (value % 16)
    return checksum

def get_raw_subtitles(movie_path, lang):
    md5 = get_md5(movie_path)
    url = URL_TEMPLATE.format(
        lang=lang.upper(),
        md5=md5,
        checksum=get_checksum(md5))

    response = requests.get(url, timeout=3)
    if response.content[0:3] == b'NPc':
        print_error('%r error: subtitles not found.' % (movie_path))
        return

    with tempfile.NamedTemporaryFile(suffix='.7z', delete=False) as arc_file:
        arc_file.write(response.content)
        arc_path = arc_file.name

    try:
        proc = subprocess.Popen(
            ['7z', 'x', '-so', '-p' + PASSWORD, arc_path],
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE)
        return proc.communicate(response.content)[0]
    finally:
        if os.path.exists(arc_path):
            os.unlink(arc_path)

def process_path(parser, movie_path, lang, force, debug):
    '''
    Stores subtitles for a single movie path.
    If the target subtitles already exist, bails out, unless force=True.
    '''
    subs_path = os.path.splitext(movie_path)[0] + '.srt'
    if os.path.exists(subs_path) and not force:
        print_warning('%r has subs, ignoring' % movie_path)
        return

    try:
        output = get_raw_subtitles(movie_path, lang)
        fps = get_fps(movie_path)
        lines = output.decode('cp1250').split('\n')
        subtitles = parser.parse(lines, fps)
        output = parser.to_srt(subtitles)

        with open(subs_path, 'wb') as sub_file:
            sub_file.write(output.encode('utf-8'))
            print_success('%r saved' % movie_path)
    except Exception as ex:
        if debug:
            raise
        print_error(ex)

def main():
    colorama.init()

    args = parse_args()
    paths = collect_paths(args.paths)
    parser = SubtitleParser()
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        for path in paths:
            func_args = [parser, path, args.lang, args.force, args.debug]
            if args.debug:
                process_path(*func_args)
            else:
                executor.submit(process_path, *func_args)

if __name__ == '__main__':
    main()
