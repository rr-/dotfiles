#!/bin/python3
# Interactive stand-alone tagger for ul-gelbooru, ul-yume etc.

import os
import sys
import re
import argparse
import json
import urwid
from urwid_readline import ReadlineEdit
from dotfiles.tag_list import TagList


def box_to_gui(str):
    return str.replace('_', ' ')


def unbox_from_gui(str):
    return str.replace(' ', '_')


class LocalTag:
    SOURCE_INITIAL = 0
    SOURCE_USER_INPUT = 1
    SOURCE_IMPLICATION = 2

    def __init__(self, name, source):
        self.name = name
        self.source = source

    def __str__(self):
        return box_to_gui(self.name)


class ReferenceTag:
    def __init__(self, name, importance, implications):
        self.name = name
        self.importance = importance
        self.implications = implications

    def __str__(self):
        return box_to_gui(self.name)


class AbortInterrupt(KeyboardInterrupt):
    pass


class ConfirmInterrupt(KeyboardInterrupt):
    pass


def _clamp(number, min_value, max_value):
    return max(min_value, min(max_value, number))


def _get_fuzzy_matches(user_input, reference_tags):
    if not user_input:
        return []
    suggestions = []
    pattern = '.*?'.join(
        re.escape(ch)
        for ch in list(user_input))
    regex = re.compile(pattern, re.I)
    for reference_tag in reference_tags:
        match = regex.search(str(reference_tag))
        if match:
            suggestions.append((-reference_tag.importance, str(reference_tag)))
    return [x for _, x in sorted(suggestions)]


class ChosenTagsListBox(urwid.ListBox):
    def __init__(self, chosen_tags, reference_tags):
        super().__init__(urwid.SimpleListWalker([]))
        self._chosen_tags = chosen_tags
        self._reference_tags = reference_tags
        self.update()
        self.num = None

    def selectable(self):
        return True

    def keypress(self, _size, key):
        keymap = {
            'j':         self._select_prev,
            'k':         self._select_next,
            'g':         self._select_first,
            'G':         self._select_last,
            'd':         self._delete_selected,
            'delete':    self._delete_selected,
        }
        if key in '0123456789':
            self.num = self.num * 10 if self.num is not None else 0
            self.num += int(key)
        elif key in keymap:
            keymap[key]()
            self.num = None
            return None
        return key

    def update(self):
        self.body.clear()
        for tag in sorted(self._chosen_tags, key=str):
            if tag.source == LocalTag.SOURCE_IMPLICATION:
                class_name = 'implied-tag'
            elif tag.source == LocalTag.SOURCE_INITIAL:
                class_name = 'initial-tag'
            elif str(tag).lower() not in self._reference_tags:
                class_name = 'new-tag'
            else:
                class_name = 'tag'
            self.body.append(
                urwid.AttrWrap(
                    urwid.Text(str(tag), wrap=urwid.CLIP),
                    class_name,
                    'focused-' + class_name))
        self._invalidate()

    def _select_next(self):
        num = self.num if self.num is not None else 1
        self.body.focus = max(self.body.focus - num, 0)
        self._invalidate()

    def _select_prev(self):
        num = self.num if self.num is not None else 1
        self.body.focus = min(self.body.focus + num, len(self.body) - 1)
        self._invalidate()

    def _select_first(self):
        if self.num is not None:
            self.body.focus = sorted((0, self.num - 1, len(self.body) - 1))[1]
        else:
            self.body.focus = 0
        self._invalidate()

    def _select_last(self):
        if self.num is not None:
            self.body.focus = sorted((0, self.num - 1, len(self.body) - 1))[1]
        else:
            self.body.focus = len(self.body) - 1
        self._invalidate()

    def _delete_selected(self):
        self._chosen_tags.remove(self.body.get_focus()[0].text)
        self.update()
        self._invalidate()


class FuzzyInput(urwid.Widget):
    signals = ['accept']

    def __init__(self, reference_tags):
        self._reference_tags = reference_tags
        self._focused_match = -1
        self._matches = []
        self._input_box = ReadlineEdit('', wrap=urwid.CLIP)
        urwid.signals.connect_signal(
            self._input_box, 'change', self._on_text_change)
        self._update_matches()

    def selectable(self):
        return True

    def keypress(self, size, key):
        keymap = {
            'enter':     self._accept,
            'tab':       self._select_prev,
            'shift tab': self._select_next,
        }
        if key in keymap:
            keymap[key](size)
            return None
        return self._input_box.keypress(size, key)

    def render(self, size, focus=False):
        maxcol, maxrow = size
        canvases = [(self._input_box.render((maxcol,)), 0, focus)]
        for i in range(maxrow - 1):
            text = self._matches[i] if i < len(self._matches) else ' '
            if len(text) > maxcol:
                text = text[0:maxcol-3] + '...'
            class_name = 'match'
            if self._focused_match == i:
                class_name = 'focused-' + class_name
            canvases.append((
                urwid.TextCanvas(
                    [text.encode()],
                    attr=[[(class_name, len(text))]],
                    maxcol=maxcol),
                i + 1,
                focus))
        canvas = urwid.CanvasCombine(canvases)
        if focus:
            canvas.cursor = (min(self._input_box.edit_pos, maxcol), 0)
        return canvas

    def _accept(self, _size):
        text = self._input_box.text
        self._input_box.text = ''
        self._update_matches()
        self._focused_match = -1
        urwid.signals.emit_signal(self, 'accept', self, text)
        self._invalidate()

    def _select_next(self, _size):
        if self._focused_match > 0:
            self._focused_match -= 1
            self._on_results_focus_change()
            self._invalidate()

    def _select_prev(self, size):
        if self._focused_match + 1 < min(len(self._matches), size[1] - 1):
            self._focused_match += 1
            self._on_results_focus_change()
            self._invalidate()

    def _on_text_change(self, *_args, **__):
        self._update_matches()

    def _on_results_focus_change(self, *_, **__):
        urwid.signals.disconnect_signal(
            self._input_box, 'change', self._on_text_change)
        self._input_box.text = self._matches[self._focused_match]
        self._input_box.edit_pos = len(self._input_box.text)
        urwid.signals.connect_signal(
            self._input_box, 'change', self._on_text_change)

    def _update_matches(self):
        self._matches = _get_fuzzy_matches(
            self._input_box.text, self._reference_tags)
        self._focused_match = _clamp(
            self._focused_match, -1, len(self._matches) - 1)


class UrwidTagger:
    def __init__(self, chosen_tags, reference_tags, title):
        del urwid.command_map['left']
        del urwid.command_map['down']
        del urwid.command_map['up']
        del urwid.command_map['right']
        self._chosen_tags = chosen_tags
        self._reference_tags = reference_tags
        self._undo_stack = []

        self._fuzzy_input = FuzzyInput(reference_tags)
        self._choices_box = ChosenTagsListBox(chosen_tags, reference_tags)
        urwid.connect_signal(
            self._fuzzy_input, 'accept', self._on_tag_accept)

        self._columns = urwid.Columns([
            urwid.LineBox(self._fuzzy_input, title='Input'),
            urwid.LineBox(self._choices_box, title='Chosen tags')])
        self._columns.set_focus(0)
        self._loop = urwid.MainLoop(
            urwid.Frame(
                self._columns,
                header=urwid.Text(title, 'center') if title else None),
            unhandled_input=self._keypress)
        self._loop.screen.set_terminal_properties(256)
        self._loop.screen.register_palette_entry(
            'focused-match', 'light green', 'default')
        self._loop.screen.register_palette_entry(
            'new-tag', 'light red', 'default',
            background_high='#FF0')
        self._loop.screen.register_palette_entry(
            'implied-tag', 'light green', 'default',
            background_high='#DFD')
        self._loop.screen.register_palette_entry(
            'initial-tag', 'dark blue', 'default',
            background_high='#DDF')
        for class_name in ('tag', 'new-tag', 'implied-tag', 'initial-tag'):
            self._loop.screen.register_palette_entry(
                'focused-' + class_name, 'black', 'white',
                background_high='#000', foreground_high='#FFF')

    def add_from_user_input(self):
        try:
            self._loop.run()
        except ConfirmInterrupt as _:
            return True
        except AbortInterrupt as _:
            return False
        except KeyboardInterrupt as _:
            return False

    def _keypress(self, key):
        keymap = {
            'ctrl c': self._abort,
            'ctrl q': self._confirm,
            'ctrl x': self._toggle_focus,
            'ctrl r': self._undo_tag,
        }
        if key in keymap:
            keymap[key]()

    def _abort(self):
        raise AbortInterrupt()

    def _confirm(self):
        raise ConfirmInterrupt()

    def _toggle_focus(self):
        if self._columns.get_focus_column() == 0:
            self._columns.set_focus(1)
        else:
            self._columns.set_focus(0)

    def _undo_tag(self):
        if not self._undo_stack:
            return
        for tag in self._undo_stack.pop():
            self._chosen_tags.remove(tag)
        self._choices_box.update()

    def _on_tag_accept(self, _widget, text):
        previous_tags = set([str(t) for t in self._chosen_tags])
        self._chosen_tags.add(LocalTag(text, LocalTag.SOURCE_USER_INPUT))
        to_check = [text]
        visited = set()
        while to_check:
            text = to_check.pop(0)
            if text in visited:
                continue
            visited.add(text)
            if text in self._reference_tags:
                for implication in self._reference_tags[text].implications:
                    self._chosen_tags.add(
                        LocalTag(implication, LocalTag.SOURCE_IMPLICATION))
                    to_check.append(implication)
        added_tags = set([str(t) for t in self._chosen_tags]) - previous_tags
        self._undo_stack.append(added_tags)
        self._choices_box.update()


def _open_tty():
    saved_stdin = os.dup(sys.stdin.fileno())
    saved_stdout = os.dup(sys.stdout.fileno())
    os.close(sys.stdin.fileno())
    os.close(sys.stdout.fileno())
    sys.stdin = open('/dev/tty', 'r')
    sys.stdout = open('/dev/tty', 'w')
    return saved_stdin, saved_stdout


def _restore_stdio(saved_stdin, saved_stdout):
    os.close(sys.stdin.fileno())
    os.close(sys.stdout.fileno())
    os.dup(saved_stdin)
    os.dup(saved_stdout)


def _get_reference_tags(cache_patch):
    cache_path = os.path.expanduser(cache_patch)
    reference_tags = TagList()
    if not os.path.exists(cache_path):
        return reference_tags
    with open(cache_path) as handle:
        for tag in json.load(handle)['tags']:
            for alias in tag['names']:
                reference_tags.add(ReferenceTag(
                    name=alias,
                    importance=tag['usages'],
                    implications=tag.get('implications', [])))
    return reference_tags


def parse_args():
    parser = argparse.ArgumentParser(
        description='Interactively choose tags')
    parser.add_argument(
        '-r', '--reference-tags', dest='reference_tags_path',
        default='~/.config/tagger.json', help='path to reference tags')
    parser.add_argument(
        '-t', '--tags', help='list of initial tags')
    parser.add_argument('--title', help='window title')
    return parser.parse_args()


def main():
    args = parse_args()
    saved_fds = _open_tty()
    chosen_tags = TagList()
    chosen_tags.add_all(
        LocalTag(x, LocalTag.SOURCE_INITIAL)
        for x in re.split(r'\s+', args.tags or ''))
    reference_tags = _get_reference_tags(args.reference_tags_path)
    tagger = UrwidTagger(chosen_tags, reference_tags, args.title)
    result = False
    try:
        result = tagger.add_from_user_input()
    finally:
        _restore_stdio(*saved_fds)
    if result:
        print('\n'.join(unbox_from_gui(str(tag)) for tag in chosen_tags))
    else:
        sys.exit(1)


if __name__ == '__main__':
    main()
