#!/usr/bin/python3
# Uploads files to yume.pl via its API and outputs copyable links

import sys
import re
import argparse
import hashlib
import json
import subprocess
from tempfile import TemporaryFile
import requests
from dotfiles import config
from dotfiles.tag_list import TagList

try:
    JSONDecodeError = json.decoder.JSONDecodeError
except:
    JSONDecodeError = ValueError


config_key = config['ul-yume']

API_URL = config_key.get('api-url', 'https://yume.pl/api')
USER_NAME = config_key['user']
PASSWORD = config_key['password']
SAFETY_MAP = {
    'safe': 'safe',
    'sketchy': 'sketchy',
    'questionable': 'sketchy',
    'unsafe': 'unsafe',
    'explicit': 'unsafe',
    's': 's',
    'q': 'q',
    'e': 'e',
    '1': 'safe',
    '2': 'sketchy',
    '3': 'unsafe',
}


class NoContentError(RuntimeError):
    pass


class LoginError(RuntimeError):
    pass


class SearchError(RuntimeError):
    pass


class PostRetrievalError(RuntimeError):
    pass


class PostUpdateError(RuntimeError):
    pass


class PostUploadError(RuntimeError):
    pass


class DuplicatePostUploadError(RuntimeError):
    def __init__(self, post_id):
        super().__init__('Image already uploaded')
        self.post_id = post_id


def parse_args():
    parser = argparse.ArgumentParser(
        description='Sends post to yume.pl from CLI')
    parser.add_argument(
        '-s', '--safety', choices=SAFETY_MAP.keys(),
        required=False, default='safe', help='safety')
    parser.add_argument(
        '--source', default='', help='source')
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        '-T', '--tag-cmd',
        help='external command to tags')
    group.add_argument(
        '-t', '--tags', help='list of space separated tags')
    parser.set_defaults(tag_cmd='tagger')
    parser.add_argument(
        metavar='POST_PATH', dest='path',
        help='path to the post')
    return parser.parse_args()


def create_session():
    session = requests.Session()
    session.headers['Accept'] = 'application/json'
    session.auth = requests.auth.HTTPBasicAuth(USER_NAME, PASSWORD)
    # actually we don't need this
    # response = session.get(API_URL + '/user/' + USER_NAME + '?bump-login')
    # if response.status_code != 200:
    #     raise LoginError(response.text)
    return session


def get_post(session, post_id):
    response = session.get(API_URL + '/post/' + str(post_id))
    decoded = json.loads(response.text)
    if response.status_code == 200:
        return decoded
    raise PostRetrievalError(decoded['description'])


def upload_post(session, content, source, safety, tags):
    with TemporaryFile() as handle:
        handle.write(content)
        handle.seek(0)
        response = session.post(
            API_URL + '/posts',
            files={
                'content': handle,
                'metadata': json.dumps({
                    'source': source,
                    'safety': SAFETY_MAP[safety],
                    'anonymous': False,
                    'tags': list(tags),
                }),
            })
        decoded = json.loads(response.text)
        if response.status_code == 200:
            return decoded
        if 'already uploaded' in decoded['description']:
            post_id = re.search(r'\d+', decoded['description']).group(0)
            raise DuplicatePostUploadError(post_id)
        raise PostUploadError(decoded['description'])


def get_file_content(args):
    if not args.path:
        raise NoContentError()
    with open(args.path, 'rb') as handle:
        return handle.read()


def get_sha1_checksum(content):
    sha1 = hashlib.sha1()
    sha1.update(content)
    return sha1.hexdigest()


def search_post_by_checksum(session, checksum):
    response = session.get(
        API_URL + '/posts?query=content-checksum:' + checksum)
    decoded = json.loads(response.text)
    if response.status_code == 200:
        if len(decoded['results']):
            return decoded['results'][0]
        return None
    raise SearchError(decoded['description'])


def search_posts_by_content(session, content):
    with TemporaryFile() as handle:
        handle.write(content)
        handle.seek(0)
        response = session.post(
            API_URL + '/posts/reverse-search',
            files={
                'content': handle,
            })
        decoded = json.loads(response.text)
        if response.status_code == 200:
            if len(decoded['results']):
                return decoded['results']
            return []
        raise SearchError(decoded['description'])


def collect_tags(args, initial_tags):
    assert args.tags or args.tag_cmd
    tags = TagList()
    tags.add_all(initial_tags)
    if args.tags is not None:
        tags.add_all(re.split(r'\s+', args.tags))
    elif args.tag_cmd:
        process = subprocess.Popen(
            [
                args.tag_cmd,
                '--tags', ' '.join(tags),
                '--title',
                'Uploading to yume: %s (safety: %s)' % (
                    args.path, args.safety),
            ],
            stdout=subprocess.PIPE)
        out, _ = process.communicate()
        tags.add_all(re.split(r'\s+', out.decode()))
    return tags


def update_post_tags(session, post_id, post_version, tags):
    response = session.put(
        API_URL + '/post/' + str(post_id),
        data=json.dumps({
            'version': post_version,
            'tags': list(tags),
        }))
    decoded = json.loads(response.text)
    if response.status_code == 200:
        return decoded
    raise PostUpdateError(decoded['description'])


def main():
    args = parse_args()

    try:
        session = create_session()
        content = get_file_content(args)
        checksum = get_sha1_checksum(content)

        post = search_post_by_checksum(session, checksum)

        if not post:
            try:
                similar_results = search_posts_by_content(session, content)
                if similar_results:
                    print('Similar posts found:')
                    for result in similar_results:
                        print('%.02f: %s (%dx%d)' % (
                            result['dist'],
                            result['post']['contentUrl'],
                            result['post']['canvasWidth'],
                            result['post']['canvasHeight']))
                    input('Hit enter to continue, ^C to abort\n')
            except SearchError:
                pass

        tags = collect_tags(args, post['tags'] if post else [])
        print('Tags:')
        print('\n'.join(tags))

        if post:
            update_post_tags(session, post['id'], post['version'], tags)
        else:
            post = upload_post(
                session, content, args.source, args.safety, tags)
        print('Uploaded.')
        print('Address: ' + post['contentUrl'])
        sys.exit(0)

    except KeyboardInterrupt:
        print('Cancelled.', file=sys.stderr)
    except PostUpdateError as ex:
        print('Error updating post: %s' % str(ex), file=sys.stderr)
    except PostUploadError as ex:
        print('Error uploading post: %s' % str(ex), file=sys.stderr)
    except LoginError as ex:
        print('Error logging in: %s' % str(ex), file=sys.stderr)
    except NoContentError:
        print('Error: nothing to send.', file=sys.stderr)
    except JSONDecodeError as ex:
        print('Error decoding JSON: %s' % str(ex.doc), file=sys.stderr)
    sys.exit(1)

if __name__ == '__main__':
    main()
