#!/usr/bin/python3
# Uploads files to yume.pl via its API and outputs copyable links

import sys
import getpass
import re
import json
import subprocess
from tempfile import TemporaryFile
from typing import Optional
import configargparse
import requests
from dotfiles.tag_list import TagList


SAFETY_MAP = {
    'safe': 'safe',
    'sketchy': 'sketchy',
    'questionable': 'sketchy',
    'unsafe': 'unsafe',
    'explicit': 'unsafe',
    's': 's',
    'q': 'q',
    'e': 'e',
    '1': 'safe',
    '2': 'sketchy',
    '3': 'unsafe',
}


class NoContentError(RuntimeError):
    pass


class LoginError(RuntimeError):
    pass


class SearchError(RuntimeError):
    pass


class PostRetrievalError(RuntimeError):
    pass


class PostUpdateError(RuntimeError):
    pass


class PostUploadError(RuntimeError):
    pass


class DuplicatePostUploadError(RuntimeError):
    def __init__(self, post_id):
        super().__init__('Image already uploaded')
        self.post_id = post_id


def parse_args():
    parser = configargparse.ArgParser(
        'Sends post to yume.pl from CLI',
        default_config_files=['~/.config/ul-yume.conf'])
    parser.add('--site-url', default='https://yume.pl/')
    parser.add('--api-url', default='https://yume.pl/api')
    parser.add('-u', '--user')
    parser.add('-p', '--password')
    parser.add(
        '-s', '--safety', choices=SAFETY_MAP.keys(),
        required=False, default='safe', help='safety')
    parser.add('--source', default='', help='source')
    group = parser.add_mutually_exclusive_group()
    group.add('-T', '--tag-cmd', help='external command to tags')
    group.add('-t', '--tags', help='list of space separated tags')
    parser.set_defaults(tag_cmd='tagger')
    parser.add(metavar='POST_PATH', dest='path', help='path to the post')
    return parser.parse_args()


def create_session(_api_url, user_name, password):
    session = requests.Session()
    session.headers['Accept'] = 'application/json'
    session.auth = requests.auth.HTTPBasicAuth(user_name, password)
    # actually we don't need this
    # response = session.get(api_url + '/user/' + user_name + '?bump-login')
    # if response.status_code != 200:
    #     raise LoginError(response.text)
    return session


def get_post(session, api_url, post_id):
    response = session.get(api_url + '/post/' + str(post_id))
    decoded = json.loads(response.text)
    if response.status_code == 200:
        return decoded
    raise PostRetrievalError(decoded['description'])


def upload_post(session, api_url, content, source, safety, tags):
    with TemporaryFile() as handle:
        handle.write(content)
        handle.seek(0)
        response = session.post(
            api_url + '/posts',
            files={
                'content': handle,
                'metadata': json.dumps({
                    'source': source,
                    'safety': SAFETY_MAP[safety],
                    'anonymous': False,
                    'tags': list(tags),
                }),
            })
        decoded = json.loads(response.text)
        if response.status_code == 200:
            return decoded
        if 'already uploaded' in decoded['description']:
            post_id = re.search(r'\d+', decoded['description']).group(0)
            raise DuplicatePostUploadError(post_id)
        raise PostUploadError(decoded['description'])


def get_file_content(path):
    if not path:
        raise NoContentError()
    with open(path, 'rb') as handle:
        return handle.read()


def find_similar_posts(session, api_url, content):
    with TemporaryFile() as handle:
        handle.write(content)
        handle.seek(0)
        response = session.post(
            api_url + '/posts/reverse-search',
            files={
                'content': handle,
            })
        decoded = json.loads(response.text)
        if response.status_code == 200:
            return decoded
        raise SearchError(decoded['description'])


def collect_tags(args, initial_tags):
    assert args.tags or args.tag_cmd
    tags = TagList()
    tags.add_all(initial_tags)
    if args.tags is not None:
        tags.add_all(re.split(r'\s+', args.tags))
    elif args.tag_cmd:
        process = subprocess.Popen(
            [
                args.tag_cmd,
                '--tags', ' '.join(tags),
                '--title',
                'Uploading to yume: %s (safety: %s)' % (
                    args.path, args.safety),
            ],
            stdout=subprocess.PIPE)
        out, _ = process.communicate()
        tags.add_all(re.split(r'\s+', out.decode()))
    return tags


def update_post_tags(session, api_url, post_id, post_version, tags):
    response = session.put(
        api_url + '/post/' + str(post_id),
        data=json.dumps({
            'version': post_version,
            'tags': list(tags),
        }))
    decoded = json.loads(response.text)
    if response.status_code == 200:
        return decoded
    raise PostUpdateError(decoded['description'])


def main():
    args = parse_args()

    site_url: str = args.site_url
    api_url: str = args.api_url
    user_name: str = args.user or input('User: ')
    password: str = args.password or getpass.getpass('Password: ')

    source: Optional[str] = args.source
    safety: str = args.safety
    path: str = args.path

    try:
        session = create_session(api_url, user_name, password)
        content = get_file_content(path)

        search_results = find_similar_posts(session, api_url, content)

        post = search_results['exactPost']
        if not post:
            try:
                similar_results = search_results['similarPosts']
                if similar_results:
                    print('Similar posts found:')
                    for result in similar_results:
                        print('%.02f: %s/post/%s (%dx%d)' % (
                            result['distance'],
                            site_url,
                            result['post']['id'],
                            result['post']['canvasWidth'],
                            result['post']['canvasHeight']))
                    input('Hit enter to continue, ^C to abort\n')
            except SearchError:
                pass

        tags = collect_tags(args, post['tags'] if post else [])
        print('Tags:')
        print('\n'.join(tags))

        if post:
            update_post_tags(
                session, api_url, post['id'], post['version'], tags)
        else:
            post = upload_post(
                session, api_url, content, source, safety, tags)
        print('Uploaded.')
        print('Address: ' + post['contentUrl'])
        sys.exit(0)

    except KeyboardInterrupt:
        print('Cancelled.', file=sys.stderr)
    except PostUpdateError as ex:
        print('Error updating post: %s' % str(ex), file=sys.stderr)
    except PostUploadError as ex:
        print('Error uploading post: %s' % str(ex), file=sys.stderr)
    except LoginError as ex:
        print('Error logging in: %s' % str(ex), file=sys.stderr)
    except NoContentError:
        print('Error: nothing to send.', file=sys.stderr)
    except json.decoder.JSONDecodeError as ex:
        print('Error decoding JSON: %s' % str(ex.doc), file=sys.stderr)
    sys.exit(1)


if __name__ == '__main__':
    main()
