#!/usr/bin/env python3
import os
import sys
import tempfile
import subprocess
import getpass
import json
import urllib.parse
from typing import Dict, Generator, Any
import configargparse
import requests
import tabulate  # also install wcwidth module


Tag = Dict


class Api:
    def __init__(self, api_url: str) -> None:
        self.session = requests.Session()
        self.session.headers['Content-Type'] = 'application/json'
        self.session.headers['Accept'] = 'application/json'
        self.api_url = api_url

    def login(self, user_name: str, password: str) -> None:
        self.session.auth = requests.auth.HTTPBasicAuth(user_name, password)
        self._bump_login(user_name)

    def collect_tags(self, query: str) -> Generator[Tag, None, None]:
        offset = 0
        while True:
            response = self._get(
                '/tags?query={}&offset={}'.format(
                    urllib.parse.quote(query), offset))
            if not response['results']:
                break
            offset += len(response['results'])
            for result in response['results']:
                yield result

    def create_tag(self, tag: Tag) -> None:
        self._post('/tags', data=tag)

    def delete_tag(self, tag: Tag) -> None:
        self._delete('/tag/' + tag['names'][0], data=tag)

    def update_tag(self, old_tag_name: str, new_tag_data: Tag) -> None:
        self._put('/tag/' + old_tag_name, data=new_tag_data)

    def _bump_login(self, user_name: str) -> None:
        self._get('/user/' + user_name + '?bump-login')

    def _get(self, url: str) -> Dict:
        return self._process_response(self.session.get(self.api_url + url))

    def _post(self, url: str, data: Any) -> Dict:
        return self._process_response(
            self.session.post(self.api_url + url, data=json.dumps(data)))

    def _put(self, url: str, data: Any) -> Dict:
        return self._process_response(
            self.session.put(self.api_url + url, data=json.dumps(data)))

    def _delete(self, url: str, data: Any = None) -> Dict:
        return self._process_response(
            self.session.delete(self.api_url + url, data=json.dumps(data)))

    def _process_response(self, response: requests.Response) -> Dict:
        if response.status_code != 200:
            raise RuntimeError(json.loads(response.text)['description'])
        return json.loads(response.text)


def confirm(text: str) -> bool:
    while True:
        result = input('{} '.format(text.strip())).lower()
        if result in ['yes', 'yep', 'yeah', 'y', 'true']:
            return True
        if result in ['no', 'nah', 'nay', 'n', 'false']:
            return False


def parse_args() -> configargparse.Namespace:
    parser = configargparse.ArgParser(
        'Edits tags on yume.pl with $EDITOR',
        default_config_files=['~/.config/yume-tag-editor.conf'])
    parser.add('--api-url', default='https://yume.pl/api')
    parser.add('-u', '--user')
    parser.add('-p', '--password')
    parser.add('query', help='query to filter the posts with')
    return parser.parse_args()


def serialize_tags(tags: Dict[int, Tag]) -> str:
    return tabulate.tabulate(
        [
            [
                tag_id,
                ' '.join(tag['names']),
                ' '.join(tag['implications']),
                ' '.join(tag['suggestions']),
                tag['category'],
            ]
            for tag_id, tag in tags.items()
        ],
        headers=['ID', 'Names', 'Implications', 'Suggestions', 'Category'],
        tablefmt='pipe')


def deserialize_tags(text: str) -> Dict[int, Tag]:
    ret: Dict[int, Tag] = {}

    past_header = False
    for i, line in enumerate(text.split('\n')):
        try:
            if not line:
                continue
            assert line.startswith('|'), 'Line should start with "|"'
            assert line.endswith('|'), 'Line should end with "|"'

            if ' ' not in line.strip():
                past_header = True
            elif past_header:
                row = [cell.strip() for cell in line.strip('|').split('|')]
                tag_id = int(row[0])
                tag_names = list(set(row[1].split()))
                tag_implications = list(set(row[2].split()))
                tag_suggestions = list(set(row[3].split()))
                tag_category = row[4]

                assert tag_id not in ret, 'Tag appears twice'

                ret[tag_id] = {
                    'names': tag_names,
                    'implications': tag_implications,
                    'suggestions': tag_suggestions,
                    'category': tag_category,
                }

        except Exception as ex:
            raise ValueError('Syntax error near line {}: {}'.format(i + 1, ex))

    if not past_header:
        raise ValueError('Syntax error: header not found')

    return ret


def edit_tags_interactively(tags: Dict[int, Tag]) -> Dict[int, Tag]:
    text = serialize_tags(tags)

    with tempfile.TemporaryDirectory() as tmp_dir:
        path = os.path.join(tmp_dir, 'tags.txt')
        with open(path, 'w') as handle:
            handle.write(text)

        while True:
            subprocess.run([os.getenv('EDITOR'), path])

            with open(path, 'r') as handle:
                text = handle.read()

            try:
                return deserialize_tags(text)
            except ValueError as ex:
                input(str(ex))


def update_tags(
        api: Api,
        old_tags: Dict[int, Tag],
        new_tags: Dict[int, Tag]) -> None:
    for old_tag_id, old_tag in old_tags.items():
        try:
            if old_tag_id not in new_tags:
                if confirm('Delete tag {}?'.format(old_tag['names'][0])):
                    api.delete_tag(old_tag)
        except Exception as ex:
            print(ex, file=sys.stderr)

    for new_tag_id, new_tag in new_tags.items():
        try:
            if new_tag_id not in old_tags:
                if confirm('Create tag {}?'.format(new_tag['names'][0])):
                    api.create_tag(new_tag)
            else:
                old_tag = old_tags[new_tag_id]

                request: Dict = {}
                for key in ['names', 'implications', 'suggestions']:
                    if sorted(old_tag[key]) != sorted(new_tag[key]):
                        request[key] = new_tag[key]
                if old_tag['category'] != new_tag['category']:
                    request['category'] = new_tag['category']

                if not request:
                    continue

                if confirm('Update tag {} ({})?'.format(
                        new_tag['names'][0], request)):
                    request['version'] = old_tag['version']
                    api.update_tag(old_tag['names'][0], request)
        except Exception as ex:
            print(ex, file=sys.stderr)


def main() -> None:
    args = parse_args()
    api_url: str = args.api_url.rstrip('/')
    user_name: str = args.user or input('User: ')
    password: str = args.password or getpass.getpass('Password: ')

    api = Api(api_url)
    api.login(user_name, password)

    old_tags = {
        i + 1: old_tag
        for i, old_tag in enumerate(
            api.collect_tags(args.query))
    }
    new_tags = edit_tags_interactively(old_tags)

    update_tags(api, old_tags, new_tags)


if __name__ == '__main__':
    main()
