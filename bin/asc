#!/bin/env python3
import math
import argparse
import os
import re
import select
import sys
import termios
import numpy
import itertools
import json
from PIL import Image
from contextlib import contextmanager

_poll = None
_TERM = os.environ.get('TERM')
if os.environ.get('TMUX'):
    _seqfmt = '\033Ptmux;\033{}\a\033\\'
elif _TERM and (_TERM == 'screen' or _TERM.startswith('screen-')):
    _seqfmt = '\033P{}\a\033\\'
else:
    _seqfmt = '{}\033\\'

def positive_int(x):
    x = int(x)
    if x < 1:
        raise argparse.ArgumentTypeError('Only positive integers allowed')
    return x

def parse_args():
    parser = argparse.ArgumentParser(description='Convert images to ASCII')
    subparsers = parser.add_subparsers()

    main_parser = subparsers.add_parser('show', help='convert image to ASCII')
    main_parser.add_argument(
        '--glyph-aspect-ratio', dest='glyph_ar', metavar='NUM', type=float, default=1.9,
        help='character aspect ratio (default: 1.9)')
    main_parser.add_argument(
        '--width', metavar='NUM', type=int, default=None,
        help='target image width (in characters)')
    main_parser.add_argument(
        '--height', metavar='NUM', type=int, default=None,
        help='target image height (in characters)')
    main_parser.add_argument(
        metavar='PATH', dest='input_path',
        help='where to get the input image from')
    main_parser.add_argument(
        '--palette', metavar='PATH', dest='palette_path',
        help='custom palette')
    main_parser.add_argument(
        '--quality', metavar='NUM', dest='quality', default=5, type=positive_int,
        help='quality (the higher the better)')
    main_parser.set_defaults(func=cmd_render_image)

    dump_parser = subparsers.add_parser(
        'dump-palette',
        help='guess palette from terminal settings and dump it to stdout')
    dump_parser.set_defaults(func=cmd_dump_palette)

    args = parser.parse_args()
    if not hasattr(args, 'func') or not args.func:
        parser.print_help()
        sys.exit(1)
    return args

def get_colorp(n):
    return get_term_color([4, n])

def get_colorfg():
    return get_term_color([10])

def get_colorbg():
    return get_term_color([11])

def get_colorcur():
    return get_term_color([12])

def from_rgb(color):
    return numpy.array([color[0], color[1], color[2]], numpy.float)

def get_term_color(ansi, timeout=1000, retries=5):
    global _poll
    if not _poll:
        _poll = select.poll()
        _poll.register(sys.stdin.fileno(), select.POLLIN)

    while _poll.poll(0):
        sys.stdin.read()

    query = '\033]' + ';'.join([str(a) for a in ansi]) + ';?' + '\007'
    os.write(0, _seqfmt.format(query).encode())

    regex = re.compile(
        '\033\\](\d+;)+rgba?:(([0-9a-f]+)/)?([0-9a-f]+)/([0-9a-f]+)/([0-9a-f]+)\007',
        re.IGNORECASE)
    match = None
    output = ''
    while not match:
        if retries < 1 or not _poll.poll(timeout):
            return None
        retries -= 1
        output += sys.stdin.read()
        match = regex.search(output)
    return [int(match.group(i)[:2], 16) for i in (4, 5, 6)]

@contextmanager
def get_term_colors():
    if not sys.stdin.isatty():
        raise RuntimeError('<stdin> is not connected to a terminal')
    tc_save = None
    try:
        tc_save = termios.tcgetattr(sys.stdin.fileno())
        tc = termios.tcgetattr(sys.stdin.fileno())
        tc[3] &= ~termios.ECHO
        tc[3] &= ~termios.ICANON
        tc[6][termios.VMIN] = 0
        tc[6][termios.VTIME] = 0
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tc)
        yield
    finally:
        if tc_save:
            termios.tcsetattr(
                sys.stdin.fileno(),
                termios.TCSANOW,
                tc_save)

def get_term_size():
    rows, columns = os.popen('stty size', 'r').read().split()
    return (int(columns), int(rows))

def get_palette():
    rgb = []
    with get_term_colors():
        for i in range(256):
            rgb.append(get_colorp(i))
    return rgb

def fit_rectangle(source_rectangle, target_rectangle):
    source_ar = source_rectangle[0] / source_rectangle[1]
    target_ar = target_rectangle[0] / target_rectangle[1]
    if target_ar < source_ar:
        scale_ratio = target_rectangle[0] / source_rectangle[0]
    else:
        scale_ratio = target_rectangle[1] / source_rectangle[1]
    output_rectangle = (
        int(source_rectangle[0] * scale_ratio),
        int(source_rectangle[1] * scale_ratio))
    output_pos = (
        (output_rectangle[0] - source_rectangle[0]) / 2,
        (output_rectangle[1] - source_rectangle[1]) / 2)
    assert output_rectangle[0] <= target_rectangle[0] + 1
    assert output_rectangle[1] <= target_rectangle[1] + 1
    return output_pos, output_rectangle

def prepare_image(palette, path, container_size, glyph_ar, quality):
    image = Image.open(path)
    pos, final_size = fit_rectangle(
        (image.width, int(image.height / glyph_ar)), container_size)
    image = image.resize(final_size, resample=Image.LANCZOS)
    image = image.convert('RGB')

    real_pix = image.load()
    pix = {}
    for y in range(image.height):
        for x in range(image.width):
            pix[x, y] = from_rgb(real_pix[x, y])

    all_colors = numpy.array([from_rgb(color) for color in palette])
    output = {}
    for y in range(image.height):
        for x in range(image.width):
            old_pixel = pix[x, y]

            # first, get a few best matching colors
            top_color_indices = numpy.linalg.norm(all_colors - old_pixel, axis=1).argsort()[:quality]

            # now try to mix them all to see which outcome is closest
            candidates = []
            for i in top_color_indices:
                color_a = all_colors[i]
                candidates.append((color_a, (i, 0, ' ')))
            for i, j in itertools.combinations_with_replacement(top_color_indices, 2):
                color_a = all_colors[i]
                color_b = all_colors[j]
                candidates.append(((color_a + color_a + color_b) / 3, (i, j, '░')))
                candidates.append(((color_a + color_b + color_b) / 3, (i, j, '▓')))
                candidates.append(((color_a + color_b) / 2, (i, j, '▒')))

            candidate_colors = numpy.array([c[0] for c in candidates])
            index = numpy.linalg.norm(candidate_colors - old_pixel, axis=1).argmin()
            entry = candidates[index]

            new_pixel = entry[0]
            output[x, y] = entry[1]
            quant_error = old_pixel - new_pixel
            if x + 1 < image.width:
                pix[x+1, y] += quant_error * 7/16
            if y + 1 < image.height:
                if x > 0:
                    pix[x-1, y+1] += quant_error * 3/16
                pix[x, y+1] += quant_error * 5/16
                if x + 1 < image.width:
                    pix[x+1, y+1] += quant_error / 16

    return image.width, image.height, output

def print_ascii(width, height, output):
    for y in range(height):
        for x in range(width):
            bg, fg, char = output[x, y]
            sys.stdout.write('\033[48;5;{0}m'.format(bg))
            sys.stdout.write('\033[38;5;{0}m'.format(fg))
            sys.stdout.write(char)
        sys.stdout.write('\033[0m\n')

def cmd_render_image(args):
    size = [args.width, args.height]
    for i in range(2):
        if not size[i]:
            terminal_size = get_term_size()
            target_size = (terminal_size[0] - 1, terminal_size[1] - 1)
            size[i] = target_size[i]
    if args.palette_path:
        with open(args.palette_path, 'r') as handle:
            palette = json.load(handle)
    else:
        palette = get_palette()
    print_ascii(*prepare_image(palette, args.input_path, size, args.glyph_ar, args.quality))

def cmd_dump_palette(args):
    palette = get_palette()
    print(json.dumps(palette))

def main():
    args = parse_args()
    args.func(args)

if __name__ == '__main__':
    main()
