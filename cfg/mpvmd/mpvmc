#!/usr/bin/env python3
import abc
import argparse
import json
import socket
from pathlib import Path

CONFIG_DIR = Path("~/.config/mpvmd").expanduser()
PLAYLISTS_DIR = CONFIG_DIR / "playlists"
PLAYLIST_EXT = ".txt"


class ClientError(RuntimeError):
    pass


def format_time(value):
    if not value:
        return "?"
    hour = int(value) // 3600
    minute = (int(value) // 60) % 60
    second = int(value) % 60
    nano = str(value - int(value))[2:5]
    return f"{hour:02d}:{minute:02d}:{second:02d}.{nano}"


def float_between(value, min_, max_):
    value = float(value)
    if value < min_ or value > max_:
        raise argparse.ArgumentTypeError(
            f"{value} must be between {min_} and {max_}"
        )
    return value


def send(args):
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect("/tmp/mpvmd.socket")
    sock.send((json.dumps({"command": args}, default=str) + "\n").encode())
    sock.shutdown(socket.SHUT_WR)
    response = b""
    while True:
        chunk = sock.recv(1024)
        if not len(chunk):
            break
        response += chunk
    sock.close()
    response = json.loads(response.decode())
    if response["error"] != "success":
        raise ClientError(response["error"])
    return response


class Command:
    name = ...

    def decorate_parser(self, parser):
        pass

    @abc.abstractmethod
    def run(self, args):
        raise NotImplementedError("not implemented")


class VolumeCommand(Command):
    name = "volume"

    def decorate_parser(self, parser):
        parser.add_argument(
            "volume",
            nargs="?",
            type=lambda value: float_between(value, 0, 100),
        )

    def run(self, args):
        if args.volume is not None:
            send(["set_property", "volume", args.volume])
        print(send(["get_property", "volume"])["data"])


class PlaybackSpeedCommand(Command):
    name = "speed"

    def decorate_parser(self, parser):
        parser.add_argument("speed", nargs="?", type=float)

    def run(self, args):
        if args.speed is not None:
            send(["set_property", "speed", args.speed])
        print(send(["get_property", "speed"])["data"])


class ShowListsCommand(Command):
    name = "showlists"

    def run(self, args):
        for path in PLAYLISTS_DIR.iterdir():
            if path.suffix == PLAYLIST_EXT:
                print(path.stem)


class ShowListCommand(Command):
    name = "showlist"

    def decorate_parser(self, parser):
        parser.add_argument("name")

    def run(self, args):
        playlist_path = PLAYLISTS_DIR / (args.name + PLAYLIST_EXT)
        print(playlist_path.read_text(), end="")


class LoadListCommand(Command):
    name = "loadlist"

    def decorate_parser(self, parser):
        parser.add_argument("name")

    def run(self, args):
        playlist_path = PLAYLISTS_DIR / (args.name + PLAYLIST_EXT)
        if not playlist_path.exists():
            raise ClientError(f"playlist {args.name} does not exist")
        send(["loadlist", playlist_path])
        send(["script-message-to", "playlist", "playlist-reset-random"])


class PrevFileCommand(Command):
    name = "prevfile"

    def run(self, args):
        send(["script-message-to", "playlist", "playlist-prev"])


class NextFileCommand(Command):
    name = "nextfile"

    def run(self, args):
        send(["script-message-to", "playlist", "playlist-next"])


class SeekCommand(Command):
    name = "seek"

    def decorate_parser(self, parser):
        parser.add_argument("pos", nargs="?")

    def run(self, args):
        if args.pos is not None:
            if ":" in args.pos:
                send(["seek", args.pos, "absolute+exact"])
            elif args.pos.startswith(("+", "-")):
                send(["seek", args.pos, "relative+exact"])
            else:
                raise ClientError("unknown time")
        pos = send(["get_property", "time-pos"])["data"]
        total = send(["get_property", "duration"])["data"]
        print(format_time(pos) + " / " + format_time(total))


class RandomCommand(Command):
    name = "random"

    def decorate_parser(self, parser):
        parser.add_argument("on", nargs="?", choices={"yes", "no"})

    def run(self, args):
        if args.on is not None:
            data = send(["get_property", "script-opts"])["data"]
            data["random_playback"] = args.on
            send(["set_property", "script-opts", data])
        data = send(["get_property", "script-opts"])["data"]
        print(data["random_playback"])


class InfoCommand(Command):
    name = "info"

    def run(self, args):
        pos = send(["get_property", "time-pos"])["data"]
        total = send(["get_property", "duration"])["data"]
        metadata = send(["get_property", "metadata"])["data"]
        print("Path:", send(["get_property", "path"])["data"])
        print("Time:", format_time(pos) + " / " + format_time(total))
        print()
        if "icy-name" in metadata:
            print("URL:", metadata.get("icy-url") or "?")
            print("Name:", metadata.get("icy-name") or "?")
            print("Title:", metadata.get("icy-title") or "?")
        else:
            print("Artist:", metadata.get("artist") or "?")
            print("Album:", metadata.get("album") or "?")
            print("Title:", metadata.get("title") or "?")
            print("Year:", metadata.get("date") or "?")
            if "/" in metadata.get("track", ""):
                print("Track:", metadata.get("track") or "?")
            else:
                print(
                    "Track: {}/{}".format(
                        metadata.get("track") or "?",
                        metadata.get("tracktotal") or "?",
                    )
                )


def parse_args():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(
        help="choose the command", dest="command"
    )
    for cls in Command.__subclasses__():
        instance = cls()
        subparser = subparsers.add_parser(cls.name)
        instance.decorate_parser(subparser)
        subparser.set_defaults(command=instance)
    args = parser.parse_args()
    if not args.command:
        parser.error("no command")
    return args


def main():
    args = parse_args()
    try:
        args.command.run(args)
    except ClientError as ex:
        print(ex)


if __name__ == "__main__":
    main()
