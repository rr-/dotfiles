#!/usr/bin/env python3
import abc
import argparse
import json
import socket
from pathlib import Path
from subprocess import run

CONFIG_DIR = Path('~/.config/mpvmd').expanduser()
PLAYLISTS_DIR = CONFIG_DIR / 'playlists'
PLAYLIST_EXT = '.txt'


class ClientError(RuntimeError):
    pass


def format_time(value):
    if not value:
        return "?"
    hour = int(value) // 3600
    minute = (int(value) // 60) % 60
    second = int(value) % 60
    nano = str(value - int(value))[2:5]
    return f'{hour:02d}:{minute:02d}:{second:02d}.{nano}'


def float_between(value, min_, max_):
    value = float(value)
    if value < min_ or value > max_:
         raise argparse.ArgumentTypeError(
            f"{value} must be between {min_} and {max_}"
        )
    return value


def send(args):
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect('/tmp/mpvmd.socket')
    sock.send((json.dumps({'command': args}, default=str) + '\n').encode())
    sock.shutdown(socket.SHUT_WR)
    response = b''
    while True:
        chunk = sock.recv(1024)
        if not len(chunk):
            break
        response += chunk
    sock.close()
    response = json.loads(response.decode())
    if response['error'] != 'success':
        raise ClientError(response['error'])
    return response


class Command:
    name = ...

    def decorate_parser(self, parser):
        pass

    @abc.abstractmethod
    def run(self, args):
        raise NotImplementedError('not implemented')


class VolumeCommand(Command):
    name = 'volume'

    def decorate_parser(self, parser):
        parser.add_argument(
            'volume',
            nargs='?',
            type=lambda value: float_between(value, 0, 100)
        )

    def run(self, args):
        if args.volume is not None:
            send(['set_property', 'volume', args.volume])
        print(send(['get_property', 'volume'])['data'])


class PlaybackSpeedCommand(Command):
    name = 'speed'

    def decorate_parser(self, parser):
        parser.add_argument('speed', nargs='?', type=float)

    def run(self, args):
        if args.speed is not None:
            send(['set_property', 'speed', args.speed])
        print(send(['get_property', 'speed'])['data'])


class ShowListsCommand(Command):
    name = 'showlists'

    def run(self, args):
        for path in PLAYLISTS_DIR.iterdir():
            if path.suffix == PLAYLIST_EXT:
                print(path.stem)


class ShowListCommand(Command):
    name = 'showlist'

    def decorate_parser(self, parser):
        parser.add_argument('name')

    def run(self, args):
        playlist_path = PLAYLISTS_DIR / (args.name + PLAYLIST_EXT)
        print(playlist_path.read_text(), end='')


class LoadListCommand(Command):
    name = 'loadlist'

    def decorate_parser(self, parser):
        parser.add_argument('name')

    def run(self, args):
        playlist_path = PLAYLISTS_DIR / (args.name + PLAYLIST_EXT)
        if not playlist_path.exists():
            raise ClientError(f'playlist {args.name} does not exist')
        send(['loadlist', playlist_path])


class PrevFileCommand(Command):
    name = 'prevfile'

    def run(self, args):
        send(['playlist-prev'])


class NextFileCommand(Command):
    name = 'nextfile'

    def run(self, args):
        send(['playlist-next'])


class SeekCommand(Command):
    name = 'seek'

    def decorate_parser(self, parser):
        parser.add_argument('pos', nargs='?')

    def run(self, args):
        if args.pos is not None:
            if ':' in args.pos:
                send(['seek', args.pos, 'absolute+exact'])
            elif args.pos.startswith(('+', '-')):
                send(['seek', args.pos, 'relative+exact'])
            else:
                raise ClientError('unknown time')
        pos = send(['get_property', 'time-pos'])['data']
        total = send(['get_property', 'duration'])['data']
        print(format_time(pos) + ' / ' + format_time(total))


def parse_args():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(
        help='choose the command', dest='command'
    )
    for cls in Command.__subclasses__():
        instance = cls()
        subparser = subparsers.add_parser(cls.name)
        instance.decorate_parser(subparser)
        subparser.set_defaults(command=instance)
    args = parser.parse_args()
    if not args.command:
        parser.error('no command')
    return args


def main():
    args = parse_args()
    try:
        args.command.run(args)
    except ClientError as ex:
        print(ex)


if __name__ == '__main__':
    main()
